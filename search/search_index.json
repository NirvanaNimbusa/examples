{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository eXamples (AKA: xamples for SEO) is a Python3 library enabling interactable, self-documenting, and self-verifying examples. These examples are attached directly to Python functions using decorators or via separate MODULE_examples.py source files. Key Features: Simple and Obvious API : Add @examples.example(*args, **kwargs) decorators for each example you want to add to a function. Auto Documenting : Examples, by default, get added to your functions docstring viewable both in interactive interpreters and when using portray or pdocs . Signature Validating : All examples can easily be checked to ensure they match the function signature (and type annotations!) with a single call ( examples.verify_all_signatures() ). Act as Tests : Examples act as additional test cases, that can easily be verified using a single test case in your favorite test runner: ( examples.test_all_examples() ). Async Compatibility : Examples can be attached and tested as easily against async functions as non-async ones. What's Missing: Class Support : Currently examples can only be attached to individual functions. Class and method support is planned for a future release. Quick Start The following guides should get you up and running using eXamples in no time. Installation - TL;DR: Run pip3 install examples within your projects virtual environment. Adding Examples - TL;DR: Add example decorators that represent each of your examples: # my_module_with_examples.py from examples import example @example ( 1 , 1 , _example_returns = 2 ) def add ( number_1 : int , number_2 : int ) -> int : return number_1 + number_2 Verify and Test Examples - TL;DR: run examples.verify_and_test_examples within your projects test cases. # test_my_module_with_examples.py from examples import verify_and_test_examples import my_module_with_examples def test_examples_verifying_signature (): verify_and_test_examples ( my_module_with_examples ) Introspect Examples - import examples from my_module_with_examples import add examples . get_examples ( add )[ 0 ] . use () == 2 Why Create Examples? I've always wanted a way to attach examples to functions in a way that would be re-useable for documentation, testing, and API proposes. Just like moving Python parameter types from comments into type annotations has made them more broadly useful, I hope examples can do the same for example calls. I hope you too find eXamples useful! ~Timothy Crosley","title":"Home"},{"location":"#quick-start","text":"The following guides should get you up and running using eXamples in no time. Installation - TL;DR: Run pip3 install examples within your projects virtual environment. Adding Examples - TL;DR: Add example decorators that represent each of your examples: # my_module_with_examples.py from examples import example @example ( 1 , 1 , _example_returns = 2 ) def add ( number_1 : int , number_2 : int ) -> int : return number_1 + number_2 Verify and Test Examples - TL;DR: run examples.verify_and_test_examples within your projects test cases. # test_my_module_with_examples.py from examples import verify_and_test_examples import my_module_with_examples def test_examples_verifying_signature (): verify_and_test_examples ( my_module_with_examples ) Introspect Examples - import examples from my_module_with_examples import add examples . get_examples ( add )[ 0 ] . use () == 2","title":"Quick Start"},{"location":"#why-create-examples","text":"I've always wanted a way to attach examples to functions in a way that would be re-useable for documentation, testing, and API proposes. Just like moving Python parameter types from comments into type annotations has made them more broadly useful, I hope examples can do the same for example calls. I hope you too find eXamples useful! ~Timothy Crosley","title":"Why Create Examples?"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to eXamples (AKA: xamples) Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting eXamples set up for local development The first step when contributing to any project is getting it set up on your local machine. eXamples aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/eXamples.git `cd eXamples poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main eXamples project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by eXamples contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-examples-aka-xamples","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to eXamples (AKA: xamples)"},{"location":"docs/contributing/1.-contributing-guide/#getting-examples-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. eXamples aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/eXamples.git `cd eXamples poetry install","title":"Getting eXamples set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main eXamples project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by eXamples contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Timothy Edmund Crosley (@timothycrosley) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make eXamples (AKA xamples) into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Timothy Edmund Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make eXamples (AKA xamples) into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"docs/quick_start/1.-installation/","text":"Install examples into your projects virtual environment: pip3 install examples OR poetry add examples OR pipenv install examples Info Optionally, you can also install eXamples using its alias xamples .","title":"1. Installation"},{"location":"docs/quick_start/2.-adding-examples/","text":"Adding Examples eXamples makes it easy to add examples to any existing function call. It also provides flexibility in where you define, and you utilize examples. Decorator Usage The most straight forward way to add examples is via the @example decorator. A decorator would be added above a function definition for each example you wish to add. This is the recommended approach for simple APIs and/or APIs with only a few examples. from examples import example @example ( 1 , number_2 = 1 ) @example ( 1 , 2 , _example_returns = 3 ) def add ( number_1 : int , number_2 : int ): return number_1 + number_2 Every positional and keyword argument passed into the decorator represents the same passed into the function. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions docstring. See the API reference documentation for a complete definition. Tip Examples save the bare minimum information when attached to a function, adding very low overhead. The next approach does provide a no-overhead alternative, but generally overhead shouldn't need to be the primary consideration. You can also combine the two approaches as needed, both for the same or different functions. Separate Example Registration Alternatively, if you have a lot of examples, you can store the examples in a separate module. This can allow you to harness the power of eXamples while keeping your implementation code clean and uncluttered. As long as you test your examples, you still won't have to worry about them ever becoming out of sync with your implementation code. To do this, you can utilize the examples.add_example_to function, to add examples to a function: # implementation.py def multiply ( number_1 : int , number_2 : int ): return number_1 * number_2 # implementation_examples.py from examples import add_examples_to from .implementation import multiply multiply_example = add_example_to ( multiply ) multiply_example ( 2 , 2 , _example_returns = 4 ) multiply_example ( 1 , 1 ) # OR add_example_to ( multiply )( 2 , 2 , _example_returns = 4 ) add_example_to ( multiply )( 1 , 1 ) # Optionally, you can even name and make these examples importable! multiply_2_by_2 = add_example_to ( multiply )( 2 , 2 , _example_returns = 4 ) add_example_to returns a function that takes the same arguments as the @example decorator used above. See the API reference documentation for a complete definition. Warning When using this approach, it's important to remember that examples won't get added if the example module is never imported. This can be overcome with documentation and/or strategically importing the examples elsewhere in your code, such as __init__.py . On the other hand, this fact can be utilized to incur the overhead of examples only when running in a development environment. Custom Registry By default eXamples creates example registries on-demand per a module that contains functions with examples. If you need more fine-tuned control over the registration or usage of examples, you can create and reuse your own example registry. from examples import Examples my_examples = Examples () @my_examples.example ( argument_1 = \"value\" ) def my_function ( argument_1 ): return argument_1","title":"2. Adding Examples"},{"location":"docs/quick_start/2.-adding-examples/#adding-examples","text":"eXamples makes it easy to add examples to any existing function call. It also provides flexibility in where you define, and you utilize examples.","title":"Adding Examples"},{"location":"docs/quick_start/2.-adding-examples/#decorator-usage","text":"The most straight forward way to add examples is via the @example decorator. A decorator would be added above a function definition for each example you wish to add. This is the recommended approach for simple APIs and/or APIs with only a few examples. from examples import example @example ( 1 , number_2 = 1 ) @example ( 1 , 2 , _example_returns = 3 ) def add ( number_1 : int , number_2 : int ): return number_1 + number_2 Every positional and keyword argument passed into the decorator represents the same passed into the function. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions docstring. See the API reference documentation for a complete definition. Tip Examples save the bare minimum information when attached to a function, adding very low overhead. The next approach does provide a no-overhead alternative, but generally overhead shouldn't need to be the primary consideration. You can also combine the two approaches as needed, both for the same or different functions.","title":"Decorator Usage"},{"location":"docs/quick_start/2.-adding-examples/#separate-example-registration","text":"Alternatively, if you have a lot of examples, you can store the examples in a separate module. This can allow you to harness the power of eXamples while keeping your implementation code clean and uncluttered. As long as you test your examples, you still won't have to worry about them ever becoming out of sync with your implementation code. To do this, you can utilize the examples.add_example_to function, to add examples to a function: # implementation.py def multiply ( number_1 : int , number_2 : int ): return number_1 * number_2 # implementation_examples.py from examples import add_examples_to from .implementation import multiply multiply_example = add_example_to ( multiply ) multiply_example ( 2 , 2 , _example_returns = 4 ) multiply_example ( 1 , 1 ) # OR add_example_to ( multiply )( 2 , 2 , _example_returns = 4 ) add_example_to ( multiply )( 1 , 1 ) # Optionally, you can even name and make these examples importable! multiply_2_by_2 = add_example_to ( multiply )( 2 , 2 , _example_returns = 4 ) add_example_to returns a function that takes the same arguments as the @example decorator used above. See the API reference documentation for a complete definition. Warning When using this approach, it's important to remember that examples won't get added if the example module is never imported. This can be overcome with documentation and/or strategically importing the examples elsewhere in your code, such as __init__.py . On the other hand, this fact can be utilized to incur the overhead of examples only when running in a development environment.","title":"Separate Example Registration"},{"location":"docs/quick_start/2.-adding-examples/#custom-registry","text":"By default eXamples creates example registries on-demand per a module that contains functions with examples. If you need more fine-tuned control over the registration or usage of examples, you can create and reuse your own example registry. from examples import Examples my_examples = Examples () @my_examples.example ( argument_1 = \"value\" ) def my_function ( argument_1 ): return argument_1","title":"Custom Registry"},{"location":"docs/quick_start/3.-testing-examples/","text":"Testing and Verifying Examples One of the great thing about using programmatically defined examples is that it enables testing, type verification, and interaction. Discovering and Interacting with Examples By default, all examples are added to the docstring of any function that includes them. These examples are grouped under an \"Examples:\" section at the bottom of the __doc__ string. If you want to use or interact with one of the examples, you can easily do so via the examples libraries get_examples function: from examples import get_examples import module_with_examples get_examples ( module_with_examples . function_with_examples )[ 0 ] . use () The function returns a list of all examples for a passed-in function or module. Any of these examples can be introspected, interacted with, and directly used. For a full definition of the actions you can perform against a single example, see the API reference documentation for the CallableExample class . Verifying Examples The most basic mechanism eXamples provides for ensuring examples don't fall out of sync with the function they call is signature_verification. Signature verification ensures the parameters presented in the example match up with the parameters of the associated function. By default, it then takes the additional step of verifying that the types provided and returned by the example match those specified by the functions type annotations. Signature verification can be performed over a single example, a function, a module, or all examples defined. In general, for most projects, a module is the right level of specificity, to ensure that signatures are verified across your project. from examples import verify_signatures import module_with_examples def test_example_signatures (): verify_signatures ( module_with_examples ) Testing Examples Beyond signature verification, examples can also operate as complete test cases for your project. When using examples as test cases, success happens when: Your example doesn't specify a return value AND calling the function with your example's provided parameters doesn't raise an exception. Your example does specify a return value AND calling the function with your example's provided parameters returns that exact return value. Your example doesn't specify a return value, but it does specify an _example_raises exception type or instance, AND a matching exception is raised when calling the function. To test examples, you can use eXample's test_examples function. This function follows the same general guidelines as signature verification, and can also run over a function or module. from examples import test_examples import module_with_examples def test_examples (): test_examples ( module_with_examples ) Testing and Verifying Examples in One Step For many projects, it makes sense to both verify the signature of and test all examples. eXamples provides a verify_and_test_examples convenience function to do them both in one step: from examples import verify_and_test_examples import module_with_examples def test_examples_including_their_signature (): verify_and_test_examples ( module_with_examples )","title":"3. Testing Examples"},{"location":"docs/quick_start/3.-testing-examples/#testing-and-verifying-examples","text":"One of the great thing about using programmatically defined examples is that it enables testing, type verification, and interaction.","title":"Testing and Verifying Examples"},{"location":"docs/quick_start/3.-testing-examples/#discovering-and-interacting-with-examples","text":"By default, all examples are added to the docstring of any function that includes them. These examples are grouped under an \"Examples:\" section at the bottom of the __doc__ string. If you want to use or interact with one of the examples, you can easily do so via the examples libraries get_examples function: from examples import get_examples import module_with_examples get_examples ( module_with_examples . function_with_examples )[ 0 ] . use () The function returns a list of all examples for a passed-in function or module. Any of these examples can be introspected, interacted with, and directly used. For a full definition of the actions you can perform against a single example, see the API reference documentation for the CallableExample class .","title":"Discovering and Interacting with Examples"},{"location":"docs/quick_start/3.-testing-examples/#verifying-examples","text":"The most basic mechanism eXamples provides for ensuring examples don't fall out of sync with the function they call is signature_verification. Signature verification ensures the parameters presented in the example match up with the parameters of the associated function. By default, it then takes the additional step of verifying that the types provided and returned by the example match those specified by the functions type annotations. Signature verification can be performed over a single example, a function, a module, or all examples defined. In general, for most projects, a module is the right level of specificity, to ensure that signatures are verified across your project. from examples import verify_signatures import module_with_examples def test_example_signatures (): verify_signatures ( module_with_examples )","title":"Verifying Examples"},{"location":"docs/quick_start/3.-testing-examples/#testing-examples","text":"Beyond signature verification, examples can also operate as complete test cases for your project. When using examples as test cases, success happens when: Your example doesn't specify a return value AND calling the function with your example's provided parameters doesn't raise an exception. Your example does specify a return value AND calling the function with your example's provided parameters returns that exact return value. Your example doesn't specify a return value, but it does specify an _example_raises exception type or instance, AND a matching exception is raised when calling the function. To test examples, you can use eXample's test_examples function. This function follows the same general guidelines as signature verification, and can also run over a function or module. from examples import test_examples import module_with_examples def test_examples (): test_examples ( module_with_examples )","title":"Testing Examples"},{"location":"docs/quick_start/3.-testing-examples/#testing-and-verifying-examples-in-one-step","text":"For many projects, it makes sense to both verify the signature of and test all examples. eXamples provides a verify_and_test_examples convenience function to do them both in one step: from examples import verify_and_test_examples import module_with_examples def test_examples_including_their_signature (): verify_and_test_examples ( module_with_examples )","title":"Testing and Verifying Examples in One Step"},{"location":"reference/examples/","text":"Module examples View Source from examples.api import ( add_example_to , example , get_examples , test_all_examples , test_examples , verify_all_signatures , verify_and_test_all_examples , verify_and_test_examples , verify_signatures , ) from examples.registry import Examples __version__ = \"0.1.2\" __all__ = [ \"__version__\" , \"add_example_to\" , \"example\" , \"example_returns\" , \"get_examples\" , \"verify_signatures\" , \"test_examples\" , \"verify_and_test_examples\" , \"verify_all_signatures\" , \"test_all_examples\" , \"verify_and_test_all_examples\" , \"Examples\" , ] Sub-modules examples.api examples.example_objects examples.registry Variables __version__ Functions add_example_to def add_example_to ( function : Callable ) -> Callable Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or, can be used once for a single example: add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to ( my_sum_function )( 1 , 1 ) View Source def add_example_to ( function : Callable ) -> Callable : \"\"\" Returns a function that when called will add an example to the provide function. This can be re - used multiple times to add multiple examples : add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or , can be used once for a single example : add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @ example decorator except it returns the produced examples , allowing you to expose it : add_example = add_example_to ( my_sum_function )( 1 , 1 ) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function ) [ - 1 ] return example_factory example def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example get_examples def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) test_all_examples def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) test_examples def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_all_signatures def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) verify_and_test_all_examples def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) verify_and_test_examples def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_signatures def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) Classes Examples class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example} \" function . __doc__ += \" \\n ------- \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) Instance variables add_to_doc_strings examples Methods example def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper get def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) test_examples def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) verify_and_test_examples def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) verify_signatures def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"Index"},{"location":"reference/examples/#module-examples","text":"View Source from examples.api import ( add_example_to , example , get_examples , test_all_examples , test_examples , verify_all_signatures , verify_and_test_all_examples , verify_and_test_examples , verify_signatures , ) from examples.registry import Examples __version__ = \"0.1.2\" __all__ = [ \"__version__\" , \"add_example_to\" , \"example\" , \"example_returns\" , \"get_examples\" , \"verify_signatures\" , \"test_examples\" , \"verify_and_test_examples\" , \"verify_all_signatures\" , \"test_all_examples\" , \"verify_and_test_all_examples\" , \"Examples\" , ]","title":"Module examples"},{"location":"reference/examples/#sub-modules","text":"examples.api examples.example_objects examples.registry","title":"Sub-modules"},{"location":"reference/examples/#variables","text":"__version__","title":"Variables"},{"location":"reference/examples/#functions","text":"","title":"Functions"},{"location":"reference/examples/#add_example_to","text":"def add_example_to ( function : Callable ) -> Callable Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or, can be used once for a single example: add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to ( my_sum_function )( 1 , 1 ) View Source def add_example_to ( function : Callable ) -> Callable : \"\"\" Returns a function that when called will add an example to the provide function. This can be re - used multiple times to add multiple examples : add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or , can be used once for a single example : add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @ example decorator except it returns the produced examples , allowing you to expose it : add_example = add_example_to ( my_sum_function )( 1 , 1 ) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function ) [ - 1 ] return example_factory","title":"add_example_to"},{"location":"reference/examples/#example","text":"def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example","title":"example"},{"location":"reference/examples/#get_examples","text":"def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" )","title":"get_examples"},{"location":"reference/examples/#test_all_examples","text":"def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type )","title":"test_all_examples"},{"location":"reference/examples/#test_examples","text":"def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"test_examples"},{"location":"reference/examples/#verify_all_signatures","text":"def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types )","title":"verify_all_signatures"},{"location":"reference/examples/#verify_and_test_all_examples","text":"def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"verify_and_test_all_examples"},{"location":"reference/examples/#verify_and_test_examples","text":"def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_and_test_examples"},{"location":"reference/examples/#verify_signatures","text":"def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_signatures"},{"location":"reference/examples/#classes","text":"","title":"Classes"},{"location":"reference/examples/#examples","text":"class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example} \" function . __doc__ += \" \\n ------- \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"Examples"},{"location":"reference/examples/#instance-variables","text":"add_to_doc_strings examples","title":"Instance variables"},{"location":"reference/examples/#methods","text":"","title":"Methods"},{"location":"reference/examples/#example_1","text":"def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper","title":"example"},{"location":"reference/examples/#get","text":"def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"get"},{"location":"reference/examples/#test_examples_1","text":"def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type )","title":"test_examples"},{"location":"reference/examples/#verify_and_test_examples_1","text":"def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types )","title":"verify_and_test_examples"},{"location":"reference/examples/#verify_signatures_1","text":"def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"verify_signatures"},{"location":"reference/examples/api/","text":"Module examples.api View Source from functools import singledispatch from types import FunctionType , ModuleType from typing import Any , Callable , List , Optional from examples import registry from examples.example_objects import CallableExample , NotDefined def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\"A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with `_example_`): - *_example_returns*: The exact result you expect the example to return. - *_example_raises*: An exception you expect the example to raise (can't be combined with above) - *_example_doc_string*: If True example is added to the functions doc string. \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example def add_example_to ( function : Callable ) -> Callable : \"\"\"Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to(my_sum_function) add_example(1, 2) add_example(2, 3, _example_returns=5) Or, can be used once for a single example: add_example_to(my_sum_function)(1, 1, _example_returns=5) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to(my_sum_function)(1, 1) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function )[ - 1 ] return example_factory @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ]: \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @get_examples.register ( FunctionType ) def _get_examples_callable ( item : FunctionType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered for a function\"\"\" module_examples = registry . module_registry . get ( item . __module__ , None ) if not module_examples : return [] return module_examples . get ( item ) @get_examples.register ( str ) def _get_examples_module_name ( item : str ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module name\"\"\" module_examples = registry . module_registry . get ( item , None ) return module_examples . examples if module_examples else [] @get_examples.register ( ModuleType ) def _get_examples_module ( item : ModuleType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module\"\"\" return _get_examples_module_name ( item . __name__ ) @singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_signatures.register ( str ) def _verify_module_name_signatures ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures for {item} module but \" \"no examples are defined for that module.\" ) module_examples . verify_signatures ( verify_types = verify_types ) @verify_signatures.register ( ModuleType ) def _verify_module_signatures ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_module_name_signatures ( item . __name__ , verify_types = verify_types ) @verify_signatures.register ( FunctionType ) def _verify_function_signature ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . verify_signature ( verify_types = verify_types ) @singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. - *verify_return_type*: If `True` all examples will have have their return value types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @test_examples.register ( str ) def _test_module_name_examples ( item : str , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried testing example for {item} module but \" \"no examples are defined for that module.\" ) module_examples . test_examples ( verify_return_type = verify_return_type ) @test_examples.register ( ModuleType ) def _test_module_examples ( item : ModuleType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module.\"\"\" _test_module_name_examples ( item . __name__ , verify_return_type = verify_return_type ) @test_examples.register ( FunctionType ) def _test_function_examples ( item : FunctionType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided function.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried testing example for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . test ( verify_return_type = verify_return_type ) @singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_and_test_examples.register ( str ) def _verify_and_test_module_name_examples ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} module \" \"but no examples are defined for that module.\" ) module_examples . verify_and_test_examples ( verify_types = verify_types ) @verify_and_test_examples.register ( ModuleType ) def _verify_and_test_module_examples ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_and_test_module_name_examples ( item . __name__ , verify_types = verify_types ) @verify_and_test_examples.register ( FunctionType ) def _verify_and_test_function_examples ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} function\" \" but no examples are defined for that function.\" ) for function_example in examples : function_example . verify_and_test ( verify_types = verify_types ) def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\"Verify all examples against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\"Tests all examples against their associated functions.\"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\"Tests all examples while verifying them against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) Functions add_example_to def add_example_to ( function : Callable ) -> Callable Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or, can be used once for a single example: add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to ( my_sum_function )( 1 , 1 ) View Source def add_example_to ( function : Callable ) -> Callable : \"\"\" Returns a function that when called will add an example to the provide function. This can be re - used multiple times to add multiple examples : add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or , can be used once for a single example : add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @ example decorator except it returns the produced examples , allowing you to expose it : add_example = add_example_to ( my_sum_function )( 1 , 1 ) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function ) [ - 1 ] return example_factory example def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example get_examples def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) test_all_examples def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) test_examples def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_all_signatures def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) verify_and_test_all_examples def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) verify_and_test_examples def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_signatures def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"API"},{"location":"reference/examples/api/#module-examplesapi","text":"View Source from functools import singledispatch from types import FunctionType , ModuleType from typing import Any , Callable , List , Optional from examples import registry from examples.example_objects import CallableExample , NotDefined def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\"A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with `_example_`): - *_example_returns*: The exact result you expect the example to return. - *_example_raises*: An exception you expect the example to raise (can't be combined with above) - *_example_doc_string*: If True example is added to the functions doc string. \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example def add_example_to ( function : Callable ) -> Callable : \"\"\"Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to(my_sum_function) add_example(1, 2) add_example(2, 3, _example_returns=5) Or, can be used once for a single example: add_example_to(my_sum_function)(1, 1, _example_returns=5) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to(my_sum_function)(1, 1) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function )[ - 1 ] return example_factory @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ]: \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @get_examples.register ( FunctionType ) def _get_examples_callable ( item : FunctionType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered for a function\"\"\" module_examples = registry . module_registry . get ( item . __module__ , None ) if not module_examples : return [] return module_examples . get ( item ) @get_examples.register ( str ) def _get_examples_module_name ( item : str ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module name\"\"\" module_examples = registry . module_registry . get ( item , None ) return module_examples . examples if module_examples else [] @get_examples.register ( ModuleType ) def _get_examples_module ( item : ModuleType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module\"\"\" return _get_examples_module_name ( item . __name__ ) @singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_signatures.register ( str ) def _verify_module_name_signatures ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures for {item} module but \" \"no examples are defined for that module.\" ) module_examples . verify_signatures ( verify_types = verify_types ) @verify_signatures.register ( ModuleType ) def _verify_module_signatures ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_module_name_signatures ( item . __name__ , verify_types = verify_types ) @verify_signatures.register ( FunctionType ) def _verify_function_signature ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . verify_signature ( verify_types = verify_types ) @singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. - *verify_return_type*: If `True` all examples will have have their return value types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @test_examples.register ( str ) def _test_module_name_examples ( item : str , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried testing example for {item} module but \" \"no examples are defined for that module.\" ) module_examples . test_examples ( verify_return_type = verify_return_type ) @test_examples.register ( ModuleType ) def _test_module_examples ( item : ModuleType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module.\"\"\" _test_module_name_examples ( item . __name__ , verify_return_type = verify_return_type ) @test_examples.register ( FunctionType ) def _test_function_examples ( item : FunctionType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided function.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried testing example for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . test ( verify_return_type = verify_return_type ) @singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_and_test_examples.register ( str ) def _verify_and_test_module_name_examples ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} module \" \"but no examples are defined for that module.\" ) module_examples . verify_and_test_examples ( verify_types = verify_types ) @verify_and_test_examples.register ( ModuleType ) def _verify_and_test_module_examples ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_and_test_module_name_examples ( item . __name__ , verify_types = verify_types ) @verify_and_test_examples.register ( FunctionType ) def _verify_and_test_function_examples ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} function\" \" but no examples are defined for that function.\" ) for function_example in examples : function_example . verify_and_test ( verify_types = verify_types ) def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\"Verify all examples against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\"Tests all examples against their associated functions.\"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\"Tests all examples while verifying them against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"Module examples.api"},{"location":"reference/examples/api/#functions","text":"","title":"Functions"},{"location":"reference/examples/api/#add_example_to","text":"def add_example_to ( function : Callable ) -> Callable Returns a function that when called will add an example to the provide function. This can be re-used multiple times to add multiple examples: add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or, can be used once for a single example: add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @example decorator except it returns the produced examples, allowing you to expose it: add_example = add_example_to ( my_sum_function )( 1 , 1 ) View Source def add_example_to ( function : Callable ) -> Callable : \"\"\" Returns a function that when called will add an example to the provide function. This can be re - used multiple times to add multiple examples : add_example = add_example_to ( my_sum_function ) add_example ( 1 , 2 ) add_example ( 2 , 3 , _example_returns = 5 ) Or , can be used once for a single example : add_example_to ( my_sum_function )( 1 , 1 , _example_returns = 5 ) The returned function follows the same signature as the @ example decorator except it returns the produced examples , allowing you to expose it : add_example = add_example_to ( my_sum_function )( 1 , 1 ) \"\"\" def example_factory ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> CallableExample : example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , _example_doc_string = _example_doc_string , ** kwargs , )( function ) return get_examples ( function ) [ - 1 ] return example_factory","title":"add_example_to"},{"location":"reference/examples/api/#example","text":"def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example","title":"example"},{"location":"reference/examples/api/#get_examples","text":"def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" )","title":"get_examples"},{"location":"reference/examples/api/#test_all_examples","text":"def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type )","title":"test_all_examples"},{"location":"reference/examples/api/#test_examples","text":"def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"test_examples"},{"location":"reference/examples/api/#verify_all_signatures","text":"def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types )","title":"verify_all_signatures"},{"location":"reference/examples/api/#verify_and_test_all_examples","text":"def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"verify_and_test_all_examples"},{"location":"reference/examples/api/#verify_and_test_examples","text":"def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_and_test_examples"},{"location":"reference/examples/api/#verify_signatures","text":"def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_signatures"},{"location":"reference/examples/example_objects/","text":"Module examples.example_objects View Source import asyncio import inspect from pprint import pformat from typing import Any , Callable , get_type_hints from pydantic import create_model class NotDefined : \"\"\"This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. \"\"\" pass class CallableExample : \"\"\"Defines a single Example call against a callable.\"\"\" __slots__ = ( \"args\" , \"kwargs\" , \"callable_object\" , \"returns\" , \"raises\" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ): self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \"Cannot specify both raises and returns on a single example.\" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ): \"\"\"Verifies that the example makes sense against the functions signature.\"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items (): type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \"return\" in annotations : test_type_hints [ \"return\" ] = annotations [ \"return\" ] typed_example_values [ \"returns\" ] = self . returns create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\"Runs the given example, giving back the result returned from running the example call.\"\"\" if inspect . iscoroutinefunction ( self . callable_object ): loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running (): return call # pragma: no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ): \"\"\"Tests the given example, ensuring the return value matches that specified.\"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ): raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised but \" f \"instead {repr(exception)} was raised\" ) return if self . raises : raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised \" f \"but instead {repr(result)} was returned\" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \"Example's expected return value of '{self.returns}' \" f \"does not not match actual return value of `{result}`\" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \"return\" in type_hints : create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), returns = type_hints [ \"return\" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ): arg_str = \", \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \", \\n \" if arg_str else \"\" arg_str += \", \\n \" . join ( f \"{name}={repr(value)}\" for name , value in self . kwargs . items () ) call_str = f \"{self.callable_object.__name__}( \\n {arg_str} \\n )\" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)}\" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)}\" return call_str def __repr__ ( self ): return f \"Example: \\n {str(self)}\" Classes CallableExample class CallableExample ( callable_object : Callable , args , kwargs , returns : Any = < class ' examples . example_objects . NotDefined '>, raises : Any = None ) Defines a single Example call against a callable. View Source class CallableExample : \"\"\" Defines a single Example call against a callable. \"\"\" __slots__ = ( \" args \" , \" kwargs \" , \" callable_object \" , \" returns \" , \" raises \" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ) : self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \" Cannot specify both raises and returns on a single example. \" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" if inspect . iscoroutinefunction ( self . callable_object ) : loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running () : return call # pragma : no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ) : arg_str = \" , \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \" , \\n \" if arg_str else \"\" arg_str += \" , \\n \" . join ( f \" {name}={repr(value)} \" for name , value in self . kwargs . items () ) call_str = f \" {self.callable_object.__name__}( \\n {arg_str} \\n ) \" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)} \" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)} \" return call_str def __repr__ ( self ) : return f \" Example: \\n {str(self)} \" Instance variables args callable_object kwargs raises returns Methods test def test ( self , verify_return_type : bool = True ) Tests the given example, ensuring the return value matches that specified. View Source def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) use def use ( self ) -> Any Runs the given example, giving back the result returned from running the example call. View Source def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" if inspect . iscoroutinefunction ( self . callable_object ) : loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running () : return call # pragma : no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs ) verify_and_test def verify_and_test ( self , verify_types : bool = True ) -> None View Source def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) verify_signature def verify_signature ( self , verify_types : bool = True ) Verifies that the example makes sense against the functions signature. View Source def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) NotDefined class NotDefined ( / , * args , ** kwargs ) This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. View Source class NotDefined : \"\"\" This exists to allow distinctly checking for a parameter not passed in vs . one that is passed in as None . \"\"\" pass","title":"Example Objects"},{"location":"reference/examples/example_objects/#module-examplesexample_objects","text":"View Source import asyncio import inspect from pprint import pformat from typing import Any , Callable , get_type_hints from pydantic import create_model class NotDefined : \"\"\"This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. \"\"\" pass class CallableExample : \"\"\"Defines a single Example call against a callable.\"\"\" __slots__ = ( \"args\" , \"kwargs\" , \"callable_object\" , \"returns\" , \"raises\" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ): self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \"Cannot specify both raises and returns on a single example.\" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ): \"\"\"Verifies that the example makes sense against the functions signature.\"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items (): type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \"return\" in annotations : test_type_hints [ \"return\" ] = annotations [ \"return\" ] typed_example_values [ \"returns\" ] = self . returns create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\"Runs the given example, giving back the result returned from running the example call.\"\"\" if inspect . iscoroutinefunction ( self . callable_object ): loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running (): return call # pragma: no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ): \"\"\"Tests the given example, ensuring the return value matches that specified.\"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ): raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised but \" f \"instead {repr(exception)} was raised\" ) return if self . raises : raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised \" f \"but instead {repr(result)} was returned\" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \"Example's expected return value of '{self.returns}' \" f \"does not not match actual return value of `{result}`\" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \"return\" in type_hints : create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), returns = type_hints [ \"return\" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ): arg_str = \", \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \", \\n \" if arg_str else \"\" arg_str += \", \\n \" . join ( f \"{name}={repr(value)}\" for name , value in self . kwargs . items () ) call_str = f \"{self.callable_object.__name__}( \\n {arg_str} \\n )\" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)}\" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)}\" return call_str def __repr__ ( self ): return f \"Example: \\n {str(self)}\"","title":"Module examples.example_objects"},{"location":"reference/examples/example_objects/#classes","text":"","title":"Classes"},{"location":"reference/examples/example_objects/#callableexample","text":"class CallableExample ( callable_object : Callable , args , kwargs , returns : Any = < class ' examples . example_objects . NotDefined '>, raises : Any = None ) Defines a single Example call against a callable. View Source class CallableExample : \"\"\" Defines a single Example call against a callable. \"\"\" __slots__ = ( \" args \" , \" kwargs \" , \" callable_object \" , \" returns \" , \" raises \" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ) : self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \" Cannot specify both raises and returns on a single example. \" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" if inspect . iscoroutinefunction ( self . callable_object ) : loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running () : return call # pragma : no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ) : arg_str = \" , \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \" , \\n \" if arg_str else \"\" arg_str += \" , \\n \" . join ( f \" {name}={repr(value)} \" for name , value in self . kwargs . items () ) call_str = f \" {self.callable_object.__name__}( \\n {arg_str} \\n ) \" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)} \" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)} \" return call_str def __repr__ ( self ) : return f \" Example: \\n {str(self)} \"","title":"CallableExample"},{"location":"reference/examples/example_objects/#instance-variables","text":"args callable_object kwargs raises returns","title":"Instance variables"},{"location":"reference/examples/example_objects/#methods","text":"","title":"Methods"},{"location":"reference/examples/example_objects/#test","text":"def test ( self , verify_return_type : bool = True ) Tests the given example, ensuring the return value matches that specified. View Source def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result )","title":"test"},{"location":"reference/examples/example_objects/#use","text":"def use ( self ) -> Any Runs the given example, giving back the result returned from running the example call. View Source def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" if inspect . iscoroutinefunction ( self . callable_object ) : loop = asyncio . get_event_loop () call = self . callable_object ( * self . args , ** self . kwargs ) if loop . is_running () : return call # pragma : no cover function = asyncio . ensure_future ( call , loop = loop ) loop . run_until_complete ( function ) return function . result () return self . callable_object ( * self . args , ** self . kwargs )","title":"use"},{"location":"reference/examples/example_objects/#verify_and_test","text":"def verify_and_test ( self , verify_types : bool = True ) -> None View Source def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types )","title":"verify_and_test"},{"location":"reference/examples/example_objects/#verify_signature","text":"def verify_signature ( self , verify_types : bool = True ) Verifies that the example makes sense against the functions signature. View Source def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values )","title":"verify_signature"},{"location":"reference/examples/example_objects/#notdefined","text":"class NotDefined ( / , * args , ** kwargs ) This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. View Source class NotDefined : \"\"\" This exists to allow distinctly checking for a parameter not passed in vs . one that is passed in as None . \"\"\" pass","title":"NotDefined"},{"location":"reference/examples/registry/","text":"Module examples.registry View Source from typing import Any , Callable , Dict , List , Optional from examples.example_objects import CallableExample , NotDefined class Examples : \"\"\"An object that holds a set of examples as they are registered.\"\"\" __slots__ = ( \"examples\" , \"add_to_doc_strings\" , \"_callable_mapping\" ) def __init__ ( self , add_to_doc_strings : bool = True ): self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )): if line . strip (): indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \"Examples:\" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example}\" function . __doc__ += \" \\n -------\" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ): new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , []) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ): self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\"Returns back any examples registered for a specific function\"\"\" return self . _callable_mapping . get ( function , []) module_registry : Dict [ str , Examples ] = {} Variables module_registry Classes Examples class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example} \" function . __doc__ += \" \\n ------- \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) Instance variables add_to_doc_strings examples Methods example def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper get def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) test_examples def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) verify_and_test_examples def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) verify_signatures def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"Registry"},{"location":"reference/examples/registry/#module-examplesregistry","text":"View Source from typing import Any , Callable , Dict , List , Optional from examples.example_objects import CallableExample , NotDefined class Examples : \"\"\"An object that holds a set of examples as they are registered.\"\"\" __slots__ = ( \"examples\" , \"add_to_doc_strings\" , \"_callable_mapping\" ) def __init__ ( self , add_to_doc_strings : bool = True ): self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )): if line . strip (): indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \"Examples:\" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example}\" function . __doc__ += \" \\n -------\" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ): new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , []) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ): self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\"Returns back any examples registered for a specific function\"\"\" return self . _callable_mapping . get ( function , []) module_registry : Dict [ str , Examples ] = {}","title":"Module examples.registry"},{"location":"reference/examples/registry/#variables","text":"module_registry","title":"Variables"},{"location":"reference/examples/registry/#classes","text":"","title":"Classes"},{"location":"reference/examples/registry/#examples","text":"class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" \\n\\n {indent_spaces} {indented_example} \" function . __doc__ += \" \\n ------- \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"Examples"},{"location":"reference/examples/registry/#instance-variables","text":"add_to_doc_strings examples","title":"Instance variables"},{"location":"reference/examples/registry/#methods","text":"","title":"Methods"},{"location":"reference/examples/registry/#example","text":"def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper","title":"example"},{"location":"reference/examples/registry/#get","text":"def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"get"},{"location":"reference/examples/registry/#test_examples","text":"def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type )","title":"test_examples"},{"location":"reference/examples/registry/#verify_and_test_examples","text":"def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types )","title":"verify_and_test_examples"},{"location":"reference/examples/registry/#verify_signatures","text":"def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"verify_signatures"}]}