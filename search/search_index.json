{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository","title":"Home"},{"location":"reference/examples/","text":"Module examples View Source from examples.api import ( example , get_examples , test_all_examples , test_examples , verify_all_signatures , verify_and_test_all_examples , verify_and_test_examples , verify_signatures , ) from examples.registry import Examples __version__ = \"0.0.2\" __all__ = [ \"__version__\" , \"example\" , \"example_returns\" , \"get_examples\" , \"verify_signatures\" , \"test_examples\" , \"verify_and_test_examples\" , \"verify_all_signatures\" , \"test_all_examples\" , \"verify_and_test_all_examples\" , \"Examples\" , ] Sub-modules examples.api examples.example_objects examples.registry Variables __version__ Functions example def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example get_examples def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) test_all_examples def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) test_examples def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_all_signatures def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) verify_and_test_all_examples def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) verify_and_test_examples def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_signatures def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) Classes Examples class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" {indent_spaces}- \\n {indent_spaces} {indented_example} \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) Instance variables add_to_doc_strings examples Methods example def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper get def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) test_examples def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) verify_and_test_examples def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) verify_signatures def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"Index"},{"location":"reference/examples/#module-examples","text":"View Source from examples.api import ( example , get_examples , test_all_examples , test_examples , verify_all_signatures , verify_and_test_all_examples , verify_and_test_examples , verify_signatures , ) from examples.registry import Examples __version__ = \"0.0.2\" __all__ = [ \"__version__\" , \"example\" , \"example_returns\" , \"get_examples\" , \"verify_signatures\" , \"test_examples\" , \"verify_and_test_examples\" , \"verify_all_signatures\" , \"test_all_examples\" , \"verify_and_test_all_examples\" , \"Examples\" , ]","title":"Module examples"},{"location":"reference/examples/#sub-modules","text":"examples.api examples.example_objects examples.registry","title":"Sub-modules"},{"location":"reference/examples/#variables","text":"__version__","title":"Variables"},{"location":"reference/examples/#functions","text":"","title":"Functions"},{"location":"reference/examples/#example","text":"def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example","title":"example"},{"location":"reference/examples/#get_examples","text":"def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" )","title":"get_examples"},{"location":"reference/examples/#test_all_examples","text":"def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type )","title":"test_all_examples"},{"location":"reference/examples/#test_examples","text":"def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"test_examples"},{"location":"reference/examples/#verify_all_signatures","text":"def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types )","title":"verify_all_signatures"},{"location":"reference/examples/#verify_and_test_all_examples","text":"def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"verify_and_test_all_examples"},{"location":"reference/examples/#verify_and_test_examples","text":"def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_and_test_examples"},{"location":"reference/examples/#verify_signatures","text":"def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_signatures"},{"location":"reference/examples/#classes","text":"","title":"Classes"},{"location":"reference/examples/#examples","text":"class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" {indent_spaces}- \\n {indent_spaces} {indented_example} \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"Examples"},{"location":"reference/examples/#instance-variables","text":"add_to_doc_strings examples","title":"Instance variables"},{"location":"reference/examples/#methods","text":"","title":"Methods"},{"location":"reference/examples/#example_1","text":"def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper","title":"example"},{"location":"reference/examples/#get","text":"def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"get"},{"location":"reference/examples/#test_examples_1","text":"def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type )","title":"test_examples"},{"location":"reference/examples/#verify_and_test_examples_1","text":"def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types )","title":"verify_and_test_examples"},{"location":"reference/examples/#verify_signatures_1","text":"def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"verify_signatures"},{"location":"reference/examples/api/","text":"Module examples.api View Source from functools import singledispatch from types import FunctionType , ModuleType from typing import Any , Callable , List , Optional from examples import registry from examples.example_objects import CallableExample , NotDefined def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\"A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with `_example_`): - *_example_returns*: The exact result you expect the example to return. - *_example_raises*: An exception you expect the example to raise (can't be combined with above) - *_example_doc_string*: If True example is added to the functions doc string. \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ]: \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @get_examples.register ( FunctionType ) def _get_examples_callable ( item : FunctionType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered for a function\"\"\" module_examples = registry . module_registry . get ( item . __module__ , None ) if not module_examples : return [] return module_examples . get ( item ) @get_examples.register ( str ) def _get_examples_module_name ( item : str ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module name\"\"\" module_examples = registry . module_registry . get ( item , None ) return module_examples . examples if module_examples else [] @get_examples.register ( ModuleType ) def _get_examples_module ( item : ModuleType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module\"\"\" return _get_examples_module_name ( item . __name__ ) @singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_signatures.register ( str ) def _verify_module_name_signatures ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures for {item} module but \" \"no examples are defined for that module.\" ) module_examples . verify_signatures ( verify_types = verify_types ) @verify_signatures.register ( ModuleType ) def _verify_module_signatures ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_module_name_signatures ( item . __name__ , verify_types = verify_types ) @verify_signatures.register ( FunctionType ) def _verify_function_signature ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . verify_signature ( verify_types = verify_types ) @singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. - *verify_return_type*: If `True` all examples will have have their return value types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @test_examples.register ( str ) def _test_module_name_examples ( item : str , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried testing example for {item} module but \" \"no examples are defined for that module.\" ) module_examples . test_examples ( verify_return_type = verify_return_type ) @test_examples.register ( ModuleType ) def _test_module_examples ( item : ModuleType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module.\"\"\" _test_module_name_examples ( item . __name__ , verify_return_type = verify_return_type ) @test_examples.register ( FunctionType ) def _test_function_examples ( item : FunctionType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided function.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried testing example for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . test ( verify_return_type = verify_return_type ) @singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_and_test_examples.register ( str ) def _verify_and_test_module_name_examples ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} module \" \"but no examples are defined for that module.\" ) module_examples . verify_and_test_examples ( verify_types = verify_types ) @verify_and_test_examples.register ( ModuleType ) def _verify_and_test_module_examples ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_and_test_module_name_examples ( item . __name__ , verify_types = verify_types ) @verify_and_test_examples.register ( FunctionType ) def _verify_and_test_function_examples ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} function\" \" but no examples are defined for that function.\" ) for function_example in examples : function_example . verify_and_test ( verify_types = verify_types ) def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\"Verify all examples against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\"Tests all examples against their associated functions.\"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\"Tests all examples while verifying them against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) Functions example def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example get_examples def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) test_all_examples def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) test_examples def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_all_signatures def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) verify_and_test_all_examples def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types ) verify_and_test_examples def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" ) verify_signatures def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"API"},{"location":"reference/examples/api/#module-examplesapi","text":"View Source from functools import singledispatch from types import FunctionType , ModuleType from typing import Any , Callable , List , Optional from examples import registry from examples.example_objects import CallableExample , NotDefined def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\"A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with `_example_`): - *_example_returns*: The exact result you expect the example to return. - *_example_raises*: An exception you expect the example to raise (can't be combined with above) - *_example_doc_string*: If True example is added to the functions doc string. \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ]: \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @get_examples.register ( FunctionType ) def _get_examples_callable ( item : FunctionType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered for a function\"\"\" module_examples = registry . module_registry . get ( item . __module__ , None ) if not module_examples : return [] return module_examples . get ( item ) @get_examples.register ( str ) def _get_examples_module_name ( item : str ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module name\"\"\" module_examples = registry . module_registry . get ( item , None ) return module_examples . examples if module_examples else [] @get_examples.register ( ModuleType ) def _get_examples_module ( item : ModuleType ) -> List [ CallableExample ]: \"\"\"Returns all examples registered to a module\"\"\" return _get_examples_module_name ( item . __name__ ) @singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_signatures.register ( str ) def _verify_module_name_signatures ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures for {item} module but \" \"no examples are defined for that module.\" ) module_examples . verify_signatures ( verify_types = verify_types ) @verify_signatures.register ( ModuleType ) def _verify_module_signatures ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_module_name_signatures ( item . __name__ , verify_types = verify_types ) @verify_signatures.register ( FunctionType ) def _verify_function_signature ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . verify_signature ( verify_types = verify_types ) @singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. - *verify_return_type*: If `True` all examples will have have their return value types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @test_examples.register ( str ) def _test_module_name_examples ( item : str , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried testing example for {item} module but \" \"no examples are defined for that module.\" ) module_examples . test_examples ( verify_return_type = verify_return_type ) @test_examples.register ( ModuleType ) def _test_module_examples ( item : ModuleType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided module.\"\"\" _test_module_name_examples ( item . __name__ , verify_return_type = verify_return_type ) @test_examples.register ( FunctionType ) def _test_function_examples ( item : FunctionType , verify_return_type : bool = True ) -> None : \"\"\"Tests all examples associated with the provided function.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried testing example for {item} function but \" \"no examples are defined for that function.\" ) for function_example in examples : function_example . test ( verify_return_type = verify_return_type ) @singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\"Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. - *verify_types*: If `True` all examples will have have their types checked against their associated functions type annotations. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" ) @verify_and_test_examples.register ( str ) def _verify_and_test_module_name_examples ( item : str , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module name.\"\"\" module_examples = registry . module_registry . get ( item , None ) if not module_examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} module \" \"but no examples are defined for that module.\" ) module_examples . verify_and_test_examples ( verify_types = verify_types ) @verify_and_test_examples.register ( ModuleType ) def _verify_and_test_module_examples ( item : ModuleType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" _verify_and_test_module_name_examples ( item . __name__ , verify_types = verify_types ) @verify_and_test_examples.register ( FunctionType ) def _verify_and_test_function_examples ( item : FunctionType , verify_types : bool = True ) -> None : \"\"\"Verify signatures associated with the provided module.\"\"\" examples = get_examples ( item ) if not examples : raise ValueError ( f \"Tried verifying example signatures and running tests for {item} function\" \" but no examples are defined for that function.\" ) for function_example in examples : function_example . verify_and_test ( verify_types = verify_types ) def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\"Verify all examples against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types ) def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\"Tests all examples against their associated functions.\"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type ) def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\"Tests all examples while verifying them against their associated functions signatures.\"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"Module examples.api"},{"location":"reference/examples/api/#functions","text":"","title":"Functions"},{"location":"reference/examples/api/#example","text":"def example ( * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs ) -> Callable A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example. Except, for the following magic parameters (all prefixed with _example_ ): _example_returns : The exact result you expect the example to return. _example_raises : An exception you expect the example to raise (can't be combined with above) _example_doc_string : If True example is added to the functions doc string. View Source def example ( * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : bool = True , ** kwargs , ) -> Callable : \"\"\" A decorator that adds an example to the decorated function. Everything passed in to the example will be passed into the wrapped function in the unchanged when testing or using the example . Except , for the following magic parameters ( all prefixed with ` _example_ ` ) : - * _example_returns * : The exact result you expect the example to return . - * _example_raises * : An exception you expect the example to raise ( can ' t be combined with above) - * _example_doc_string * : If True example is added to the functions doc string . \"\"\" def wrap_example ( function : Callable ) -> Callable : attached_module_name = function . __module__ if attached_module_name not in registry . module_registry : registry . module_registry [ attached_module_name ] = registry . Examples () module_registry = registry . module_registry [ attached_module_name ] return module_registry . example ( * args , _example_returns = _example_returns , _example_raises = _example_raises , ** kwargs )( function ) return wrap_example","title":"example"},{"location":"reference/examples/api/#get_examples","text":"def get_examples ( item : Any ) -> List [ examples . example_objects . CallableExample ] Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. View Source @singledispatch def get_examples ( item : Any ) -> List [ CallableExample ] : \"\"\"Returns all examples associated with the provided item. Provided item should be of type function, module, or module name. \"\"\" raise NotImplementedError ( f \"Currently examples can not be attached to {type(item)}.\" )","title":"get_examples"},{"location":"reference/examples/api/#test_all_examples","text":"def test_all_examples ( verify_return_type : bool = False ) -> None Tests all examples against their associated functions. View Source def test_all_examples ( verify_return_type : bool = False ) -> None : \"\"\" Tests all examples against their associated functions. \"\"\" for module_name in registry . module_registry : test_examples ( module_name , verify_return_type = verify_return_type )","title":"test_all_examples"},{"location":"reference/examples/api/#test_examples","text":"def test_examples ( item : Any , verify_return_type : bool = True ) -> None Run all examples verifying they work as defined against the associated function. Provided item should be of type function, module, or module name. verify_return_type : If True all examples will have have their return value types checked against their associated functions type annotations. View Source @ singledispatch def test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Run all examples verifying they work as defined against the associated function. Provided item should be of type function , module , or module name . - * verify_return_type * : If ` True ` all examples will have have their return value types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"test_examples"},{"location":"reference/examples/api/#verify_all_signatures","text":"def verify_all_signatures ( verify_types : bool = False ) -> None Verify all examples against their associated functions signatures. View Source def verify_all_signatures ( verify_types : bool = False ) -> None : \"\"\" Verify all examples against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_signatures ( module_name , verify_types = verify_types )","title":"verify_all_signatures"},{"location":"reference/examples/api/#verify_and_test_all_examples","text":"def verify_and_test_all_examples ( verify_types : bool = False ) -> None Tests all examples while verifying them against their associated functions signatures. View Source def verify_and_test_all_examples ( verify_types : bool = False ) -> None : \"\"\" Tests all examples while verifying them against their associated functions signatures. \"\"\" for module_name in registry . module_registry : verify_and_test_examples ( module_name , verify_types = verify_types )","title":"verify_and_test_all_examples"},{"location":"reference/examples/api/#verify_and_test_examples","text":"def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_and_test_examples ( item : Any , verify_return_type : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item then runs all examples verifying they work as defined . Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_and_test_examples"},{"location":"reference/examples/api/#verify_signatures","text":"def verify_signatures ( item : Any , verify_types : bool = True ) -> None Verifies the signature of all examples associated with the provided item. Provided item should be of type function, module, or module name. verify_types : If True all examples will have have their types checked against their associated functions type annotations. View Source @ singledispatch def verify_signatures ( item : Any , verify_types : bool = True ) -> None : \"\"\" Verifies the signature of all examples associated with the provided item. Provided item should be of type function , module , or module name . - * verify_types * : If ` True ` all examples will have have their types checked against their associated functions type annotations . \"\"\" raise NotImplementedError ( f \" Currently examples can not be attached to {type(item)}. \" )","title":"verify_signatures"},{"location":"reference/examples/example_objects/","text":"Module examples.example_objects View Source import inspect from pprint import pformat from typing import Any , Callable , get_type_hints from pydantic import create_model class NotDefined : \"\"\"This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. \"\"\" pass class CallableExample : \"\"\"Defines a single Example call against a callable.\"\"\" __slots__ = ( \"args\" , \"kwargs\" , \"callable_object\" , \"returns\" , \"raises\" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ): self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \"Cannot specify both raises and returns on a single example.\" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ): \"\"\"Verifies that the example makes sense against the functions signature.\"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items (): type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \"return\" in annotations : test_type_hints [ \"return\" ] = annotations [ \"return\" ] typed_example_values [ \"returns\" ] = self . returns create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\"Runs the given example, giving back the result returned from running the example call.\"\"\" return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ): \"\"\"Tests the given example, ensuring the return value matches that specified.\"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ): raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised but \" f \"instead {repr(exception)} was raised\" ) return if self . raises : raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised \" f \"but instead {repr(result)} was returned\" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \"Example's expected return value of '{self.returns}' \" f \"does not not match actual return value of `{result}`\" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \"return\" in type_hints : create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), returns = type_hints [ \"return\" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ): arg_str = \", \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \", \\n \" if arg_str else \"\" arg_str += \", \\n \" . join ( f \"{name}={repr(value)}\" for name , value in self . kwargs . items () ) call_str = f \"{self.callable_object.__name__}( \\n {arg_str} \\n )\" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)}\" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)}\" return call_str Classes CallableExample class CallableExample ( callable_object : Callable , args , kwargs , returns : Any = < class ' examples . example_objects . NotDefined '>, raises : Any = None ) Defines a single Example call against a callable. View Source class CallableExample : \"\"\" Defines a single Example call against a callable. \"\"\" __slots__ = ( \" args \" , \" kwargs \" , \" callable_object \" , \" returns \" , \" raises \" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ) : self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \" Cannot specify both raises and returns on a single example. \" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ) : arg_str = \" , \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \" , \\n \" if arg_str else \"\" arg_str += \" , \\n \" . join ( f \" {name}={repr(value)} \" for name , value in self . kwargs . items () ) call_str = f \" {self.callable_object.__name__}( \\n {arg_str} \\n ) \" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)} \" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)} \" return call_str Instance variables args callable_object kwargs raises returns Methods test def test ( self , verify_return_type : bool = True ) Tests the given example, ensuring the return value matches that specified. View Source def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) use def use ( self ) -> Any Runs the given example, giving back the result returned from running the example call. View Source def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" return self . callable_object ( * self . args , ** self . kwargs ) verify_and_test def verify_and_test ( self , verify_types : bool = True ) -> None View Source def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) verify_signature def verify_signature ( self , verify_types : bool = True ) Verifies that the example makes sense against the functions signature. View Source def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) NotDefined class NotDefined ( / , * args , ** kwargs ) This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. View Source class NotDefined : \"\"\" This exists to allow distinctly checking for a parameter not passed in vs . one that is passed in as None . \"\"\" pass","title":"Example Objects"},{"location":"reference/examples/example_objects/#module-examplesexample_objects","text":"View Source import inspect from pprint import pformat from typing import Any , Callable , get_type_hints from pydantic import create_model class NotDefined : \"\"\"This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. \"\"\" pass class CallableExample : \"\"\"Defines a single Example call against a callable.\"\"\" __slots__ = ( \"args\" , \"kwargs\" , \"callable_object\" , \"returns\" , \"raises\" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ): self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \"Cannot specify both raises and returns on a single example.\" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ): \"\"\"Verifies that the example makes sense against the functions signature.\"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items (): type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \"return\" in annotations : test_type_hints [ \"return\" ] = annotations [ \"return\" ] typed_example_values [ \"returns\" ] = self . returns create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\"Runs the given example, giving back the result returned from running the example call.\"\"\" return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ): \"\"\"Tests the given example, ensuring the return value matches that specified.\"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ): raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised but \" f \"instead {repr(exception)} was raised\" ) return if self . raises : raise AssertionError ( f \"Example expected {repr(self.raises)} to be raised \" f \"but instead {repr(result)} was returned\" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \"Example's expected return value of '{self.returns}' \" f \"does not not match actual return value of `{result}`\" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \"return\" in type_hints : create_model ( # type: ignore getattr ( self . callable_object , \"__name__\" , \"ExamplesModel\" ), returns = type_hints [ \"return\" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ): arg_str = \", \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \", \\n \" if arg_str else \"\" arg_str += \", \\n \" . join ( f \"{name}={repr(value)}\" for name , value in self . kwargs . items () ) call_str = f \"{self.callable_object.__name__}( \\n {arg_str} \\n )\" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)}\" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)}\" return call_str","title":"Module examples.example_objects"},{"location":"reference/examples/example_objects/#classes","text":"","title":"Classes"},{"location":"reference/examples/example_objects/#callableexample","text":"class CallableExample ( callable_object : Callable , args , kwargs , returns : Any = < class ' examples . example_objects . NotDefined '>, raises : Any = None ) Defines a single Example call against a callable. View Source class CallableExample : \"\"\" Defines a single Example call against a callable. \"\"\" __slots__ = ( \" args \" , \" kwargs \" , \" callable_object \" , \" returns \" , \" raises \" ) def __init__ ( self , callable_object : Callable , args , kwargs , returns : Any = NotDefined , raises : Any = None ) : self . args = args self . kwargs = kwargs self . callable_object = callable_object if raises and returns is not NotDefined : raise ValueError ( \" Cannot specify both raises and returns on a single example. \" ) self . returns = returns self . raises = raises def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values ) def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" return self . callable_object ( * self . args , ** self . kwargs ) def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result ) def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types ) def __str__ ( self ) : arg_str = \" , \\n \" . join ( repr ( arg ) for arg in self . args ) if self . kwargs : arg_str += \" , \\n \" if arg_str else \"\" arg_str += \" , \\n \" . join ( f \" {name}={repr(value)} \" for name , value in self . kwargs . items () ) call_str = f \" {self.callable_object.__name__}( \\n {arg_str} \\n ) \" if self . returns is not NotDefined : call_str += f \" \\n == \\n {pformat(self.returns)} \" elif self . raises : call_str += f \" \\n raises {pformat(self.raises)} \" return call_str","title":"CallableExample"},{"location":"reference/examples/example_objects/#instance-variables","text":"args callable_object kwargs raises returns","title":"Instance variables"},{"location":"reference/examples/example_objects/#methods","text":"","title":"Methods"},{"location":"reference/examples/example_objects/#test","text":"def test ( self , verify_return_type : bool = True ) Tests the given example, ensuring the return value matches that specified. View Source def test ( self , verify_return_type : bool = True ) : \"\"\" Tests the given example, ensuring the return value matches that specified. \"\"\" try : result = self . use () except BaseException as exception : if not self . raises : raise if ( type ( self . raises ) == type and not isinstance ( exception , self . raises )) or ( type ( self . raises ) != type and ( not isinstance ( exception , type ( self . raises )) or self . raises . args != exception . args ) ) : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised but \" f \" instead {repr(exception)} was raised \" ) return if self . raises : raise AssertionError ( f \" Example expected {repr(self.raises)} to be raised \" f \" but instead {repr(result)} was returned \" ) elif self . returns is not NotDefined : if result != self . returns : raise AssertionError ( f \" Example's expected return value of '{self.returns}' \" f \" does not not match actual return value of `{result}` \" ) if verify_return_type : type_hints = get_type_hints ( self . callable_object ) if type_hints and \" return \" in type_hints : create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , returns = type_hints [ \" return \" ], )( returns = result )","title":"test"},{"location":"reference/examples/example_objects/#use","text":"def use ( self ) -> Any Runs the given example, giving back the result returned from running the example call. View Source def use ( self ) -> Any : \"\"\" Runs the given example, giving back the result returned from running the example call. \"\"\" return self . callable_object ( * self . args , ** self . kwargs )","title":"use"},{"location":"reference/examples/example_objects/#verify_and_test","text":"def verify_and_test ( self , verify_types : bool = True ) -> None View Source def verify_and_test ( self , verify_types : bool = True ) -> None : self . verify_signature ( verify_types = verify_types ) self . test ( verify_return_type = verify_types )","title":"verify_and_test"},{"location":"reference/examples/example_objects/#verify_signature","text":"def verify_signature ( self , verify_types : bool = True ) Verifies that the example makes sense against the functions signature. View Source def verify_signature ( self , verify_types : bool = True ) : \"\"\" Verifies that the example makes sense against the functions signature. \"\"\" bound = inspect . signature ( self . callable_object ) . bind ( * self . args , ** self . kwargs ) annotations = get_type_hints ( self . callable_object ) if verify_types and annotations : test_type_hints = {} typed_example_values = {} for parameter_name , parameter_value in bound . arguments . items () : type_hint = annotations . get ( parameter_name , None ) test_type_hints [ parameter_name ] = ( type_hint , None ) typed_example_values [ parameter_name ] = parameter_value if self . returns is not NotDefined and \" return \" in annotations : test_type_hints [ \" return \" ] = annotations [ \" return \" ] typed_example_values [ \" returns \" ] = self . returns create_model ( # type : ignore getattr ( self . callable_object , \" __name__ \" , \" ExamplesModel \" ) , ** test_type_hints )( ** typed_example_values )","title":"verify_signature"},{"location":"reference/examples/example_objects/#notdefined","text":"class NotDefined ( / , * args , ** kwargs ) This exists to allow distinctly checking for a parameter not passed in vs. one that is passed in as None. View Source class NotDefined : \"\"\" This exists to allow distinctly checking for a parameter not passed in vs . one that is passed in as None . \"\"\" pass","title":"NotDefined"},{"location":"reference/examples/registry/","text":"Module examples.registry View Source from typing import Any , Callable , Dict , List , Optional from examples.example_objects import CallableExample , NotDefined class Examples : \"\"\"An object that holds a set of examples as they are registered.\"\"\" __slots__ = ( \"examples\" , \"add_to_doc_strings\" , \"_callable_mapping\" ) def __init__ ( self , add_to_doc_strings : bool = True ): self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )): if line . strip (): indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \"Examples:\" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \"{indent_spaces}- \\n {indent_spaces} {indented_example}\" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ): new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , []) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ): self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\"Returns back any examples registered for a specific function\"\"\" return self . _callable_mapping . get ( function , []) module_registry : Dict [ str , Examples ] = {} Variables module_registry Classes Examples class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" {indent_spaces}- \\n {indent_spaces} {indented_example} \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) Instance variables add_to_doc_strings examples Methods example def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper get def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] ) test_examples def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) verify_and_test_examples def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) verify_signatures def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"Registry"},{"location":"reference/examples/registry/#module-examplesregistry","text":"View Source from typing import Any , Callable , Dict , List , Optional from examples.example_objects import CallableExample , NotDefined class Examples : \"\"\"An object that holds a set of examples as they are registered.\"\"\" __slots__ = ( \"examples\" , \"add_to_doc_strings\" , \"_callable_mapping\" ) def __init__ ( self , add_to_doc_strings : bool = True ): self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )): if line . strip (): indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \"Examples:\" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \"{indent_spaces}- \\n {indent_spaces} {indented_example}\" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ): new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , []) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ): self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\"Returns back any examples registered for a specific function\"\"\" return self . _callable_mapping . get ( function , []) module_registry : Dict [ str , Examples ] = {}","title":"Module examples.registry"},{"location":"reference/examples/registry/#variables","text":"module_registry","title":"Variables"},{"location":"reference/examples/registry/#classes","text":"","title":"Classes"},{"location":"reference/examples/registry/#examples","text":"class Examples ( add_to_doc_strings : bool = True ) An object that holds a set of examples as they are registered. View Source class Examples : \"\"\" An object that holds a set of examples as they are registered. \"\"\" __slots__ = ( \" examples \" , \" add_to_doc_strings \" , \" _callable_mapping \" ) def __init__ ( self , add_to_doc_strings : bool = True ) : self . examples : List [ CallableExample ] = [] self . add_to_doc_strings : bool = add_to_doc_strings self . _callable_mapping : Dict [ Callable , list ] = {} def _add_to_doc_string ( self , function : Callable , example : CallableExample ) -> None : if function . __doc__ is None : function . __doc__ = \"\" indent : int = 4 for line in reversed ( function . __doc__ . split ( \" \\n \" )) : if line . strip () : indent = len ( line ) - len ( line . lstrip ( \" \" )) indent_spaces : str = \" \" * indent if \" Examples: \" not in function . __doc__ : function . __doc__ += f \" \\n\\n {indent_spaces}Examples: \\n\\n \" indented_example = str ( example ) . replace ( \" \\n \" , f \" \\n {indent_spaces} \" ) function . __doc__ += f \" {indent_spaces}- \\n {indent_spaces} {indented_example} \" def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types ) def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type ) def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types ) def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"Examples"},{"location":"reference/examples/registry/#instance-variables","text":"add_to_doc_strings examples","title":"Instance variables"},{"location":"reference/examples/registry/#methods","text":"","title":"Methods"},{"location":"reference/examples/registry/#example","text":"def example ( self , * args , _example_returns : Any = < class ' examples . example_objects . NotDefined '>, _example_raises : Any = None , _example_doc_string : Union [ bool , NoneType ] = None , ** kwargs ) -> Callable View Source def example ( self , * args , _example_returns : Any = NotDefined , _example_raises : Any = None , _example_doc_string : Optional [ bool ] = None , ** kwargs , ) -> Callable : def example_wrapper ( function ) : new_example = CallableExample ( function , returns = _example_returns , raises = _example_raises , args = args , kwargs = kwargs ) self . _callable_mapping . setdefault ( function , [] ) . append ( new_example ) if _example_doc_string or ( _example_doc_string is None and self . add_to_doc_strings ) : self . _add_to_doc_string ( function , new_example ) self . examples . append ( new_example ) return function return example_wrapper","title":"example"},{"location":"reference/examples/registry/#get","text":"def get ( self , function : Callable ) -> List [ examples . example_objects . CallableExample ] Returns back any examples registered for a specific function View Source def get ( self , function : Callable ) -> List [ CallableExample ]: \"\"\" Returns back any examples registered for a specific function \"\"\" return self . _callable_mapping . get ( function , [] )","title":"get"},{"location":"reference/examples/registry/#test_examples","text":"def test_examples ( self , verify_return_type : bool = True ) -> None View Source def test_examples ( self , verify_return_type : bool = True ) -> None : for example in self . examples : example . test ( verify_return_type = verify_return_type )","title":"test_examples"},{"location":"reference/examples/registry/#verify_and_test_examples","text":"def verify_and_test_examples ( self , verify_types : bool = True ) -> None View Source def verify_and_test_examples ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_and_test ( verify_types = verify_types )","title":"verify_and_test_examples"},{"location":"reference/examples/registry/#verify_signatures","text":"def verify_signatures ( self , verify_types : bool = True ) -> None View Source def verify_signatures ( self , verify_types : bool = True ) -> None : for example in self . examples : example . verify_signature ( verify_types = verify_types )","title":"verify_signatures"}]}